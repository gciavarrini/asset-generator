name: Kind Cluster with Korifi

on:
  push

jobs:
  setup-and-install:
    runs-on: ubuntu-latest
    steps:
      # Workaround for https://github.com/nektos/act/issues/107
      # - run: sudo id

      - name: Checkout code
        uses: actions/checkout@master
      
      - name: Setup Kind
        uses: engineerd/setup-kind@v0.6.2
        with:
          version: "v0.24.0"
          name: korifi
          config: hack/kind-config.yaml
      
      - name: Validate KinD cluster creation
        run: |
          kubectl cluster-info
          kubectl version
          kubectl get pods -n kube-system
          kubectl wait --for=condition=Ready pods --all -n kube-system
      
      - name: Install Korifi
        run: |
          kubectl apply -f https://github.com/cloudfoundry/korifi/releases/latest/download/install-korifi-kind.yaml

      - name: Wait for Korifi Installation
        run: |
          echo "‚è≥ Waiting for Korifi installation to complete (up to 10 minutes)..."
          sleep 2
          kubectl wait --for=jsonpath='{.status.phase}'=Running pod/$(kubectl get pods -n korifi-installer -l job-name=install-korifi --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1:].metadata.name}') --timeout=5m -n korifi-installer
          
          MAX_RETRIES=60 # 5 minutes (60 * 5 seconds)
          RETRY_COUNT=0
          echo "üïñ Korifi is starting up..."
          while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
            if kubectl -n korifi-installer logs job/install-korifi | grep -q "Waiting for the local docker registry to start..."; then
              echo "‚úÖ Korifi installer is ready"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
          done
          
          echo "‚è≥ Waiting for Korifi API pods..."
          TOTAL_POD_COUNT=$(kubectl get pods -n korifi -l app=korifi-api -o jsonpath='{.items[*].metadata.name}' | wc -w)
          if [[ "$TOTAL_POD_COUNT" -gt 0 ]]; then
            kubectl wait --for=condition=ready pod -l app=korifi-api -n korifi --timeout=5m
          fi
          echo "‚úÖ Korifi pods are ready!"

          echo "‚è≥ Waiting for Korifi API service..."
          TIMEOUT=300 # 5 minutes timeout in seconds
          START_TIME=$(date +%s)
          while true; do
            if kubectl get svc korifi-api-svc -n korifi >/dev/null 2>&1; then
              echo "‚úÖ Korifi API service found!"
              break
            fi
            
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            if [[ $ELAPSED_TIME -ge $TIMEOUT ]]; then
              echo "‚ùå Timeout waiting for Korifi API service."
              kubectl get svc -n korifi
              exit 1
            fi
            sleep 5
          done

      - name: Expose Korifi API via NodePort
        run: |
            kubectl patch svc korifi-api-svc -n korifi --type='json' -p='[{"op": "replace", "path": "/spec/type", "value": "NodePort"}]'
  
      - name: Install cf CLI
        run: |
          wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | sudo gpg --dearmor -o /usr/share/keyrings/cli.cloudfoundry.org.gpg
          echo "deb [signed-by=/usr/share/keyrings/cli.cloudfoundry.org.gpg] https://packages.cloudfoundry.org/debian stable main" | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list
          sudo apt-get update
          sudo apt-get install cf8-cli

      - name: Test Korifi
        run: |
          echo "Target Korifi API"
          
          # Get Korifi API NodePort and Node IP
          NODE_PORT=$(kubectl get svc korifi-api-svc -n korifi -o jsonpath="{.spec.ports[0].nodePort}")
          NODE_IP=$(kubectl get nodes --namespace korifi -o jsonpath="{.items[0].status.addresses[0].address}")
          export CF_API="https://$NODE_IP:$NODE_PORT"
          # Debug: Print the calculated values
          echo "Korifi API NodePort: $NODE_PORT"
          echo "Korifi API Node IP: $NODE_IP"

          # Test the endpoint using curl
          echo "Testing Korifi API with curl..."
          curl -k -i https://$NODE_IP:$NODE_PORT 
         
          # Test the endpoint using cf cli
          echo "Testing Korifi API with cf CLI..."
          cf api https://$NODE_IP:$NODE_PORT --skip-ssl-validation
          cf auth kind-korifi
          cf create-org org && cf create-space -o org space && cf target -o org -s space
          cf push nginx --docker-image https://nginx.apps-127-0-0-1.nip.io
          curl -k -s -o /dev/null -w "%{http_code}" https://nginx.apps-127-0-0-1.nip.io

      # CURL_STATUS_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" https://nginx.apps-127-0-0-1.nip.io)
      #     # add curl check here
      #     echo "pushed to check still"

      # - name: Test Korifi
      #   run: |
          
      #     echo "Target Korifi API"
      #     export NODE_PORT=$(kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services localregistry-docker-registry)
      #     export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath="{.items[0].status.addresses[0].address}")
      #     echo http://$NODE_IP:$NODE_PORT
      #     cf api
      #     CF_API_ENDPOINT="https://host.docker.internal" # Or your host's IP
      #     echo "CF_API_ENDPOINT: $CF_API_ENDPOINT"
      #     cf api "$CF_API_ENDPOINT" --skip-ssl-validation
      #     # cf api https://localhost --skip-ssl-validation
      #     # echo "Authenticate as the cf admin user"
      #     # cf auth kind-korifi
      #     # echo "Create and target an org and a space"
      #     # cf create-org org && cf create-space -o org space && cf target -o org
      #     # echo "Push a docker app and access it"
      #     # cf push nginx --docker-image nginxinc/nginx-unprivileged:1.23.2
      #     # curl -k 
      #     # CURL_STATUS_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" https://nginx.apps-127-0-0-1.nip.io)

      #     # if [[ $CURL_STATUS_CODE != 200 ]]; then
      #     #   echo "‚ùå Nginx application failed health check. Status code: $CURL_STATUS_CODE"
      #     #   exit 1
      #     # fi

      #     # echo "‚úÖ Nginx application is healthy."

